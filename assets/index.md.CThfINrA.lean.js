import{_ as e,c as t,o as a}from"./chunks/framework.ez0Caocs.js";const p=JSON.parse('{"title":"","description":"","frontmatter":{"layout":"home","hero":{"name":"SyncGuard","text":"Distributed locks that feel like local locks","tagline":"One `await lock()` call to prevent race conditions across your services. TypeScript library with fencing tokens, auto-cleanup, and bulletproof concurrency.","image":{"src":"/hero.svg","alt":"SyncGuard - Distributed locking across microservices"},"actions":[{"theme":"brand","text":"What is SyncGuard?","link":"/what-is-syncguard"},{"theme":"alt","text":"Get Started","link":"/getting-started"}]},"features":[{"title":"Automatic Safety","icon":"🛡️","details":"Fencing tokens and ownership tracking prevent stale lock problems. Your critical sections stay protected even when processes crash or networks fail."},{"title":"Zero-Config Cleanup","icon":"🧹","details":"TTL-based expiration means locks automatically release. No manual cleanup, no orphaned locks, no midnight pages about stuck resources."},{"title":"Backend Flexibility","icon":"🔄","details":"Switch between Redis, PostgreSQL, and Firestore without changing your code. Same API, same guarantees, different infrastructure."},{"title":"Built for TypeScript","icon":"💙","details":"Full type safety with discriminated unions and capability inference. Know at compile-time what guarantees your backend provides."},{"title":"Smart Retries","icon":"🔁","details":"Exponential backoff with jitter handles contention automatically. Configure max retries, timeout, and backoff strategy to match your needs."},{"title":"Production Ready","icon":"🎯","details":"Automatic cleanup via `await using`, comprehensive error handling, onReleaseError callbacks, and optional telemetry. Built-in observability for production systems."}]},"headers":[],"relativePath":"index.md","filePath":"index.md","lastUpdated":1760710468000}'),i={name:"index.md"};function n(o,r,s,c,l,d){return a(),t("div")}const m=e(i,[["render",n]]);export{p as __pageData,m as default};
