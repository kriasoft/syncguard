import{_ as a,c as r,o as n,aj as t}from"./chunks/framework.Bbpi2Fiw.js";const p=JSON.parse('{"title":"ADR-006 Mandatory Uniform Key Truncation","description":"","frontmatter":{},"headers":[],"relativePath":"adr/006-mandatory-key-truncation.md","filePath":"adr/006-mandatory-key-truncation.md","lastUpdated":1764705171000}'),i={name:"adr/006-mandatory-key-truncation.md"};function o(s,e,c,l,d,m){return n(),r("div",null,[...e[0]||(e[0]=[t('<h1 id="adr-006-mandatory-uniform-key-truncation" tabindex="-1">ADR-006 Mandatory Uniform Key Truncation <a class="header-anchor" href="#adr-006-mandatory-uniform-key-truncation" aria-label="Permalink to “ADR-006 Mandatory Uniform Key Truncation”">​</a></h1><p><strong>Status:</strong> Accepted <strong>Date:</strong> 2025-09 <strong>Tags:</strong> keys, consistency, cross-backend</p><h2 id="problem" tabindex="-1">Problem <a class="header-anchor" href="#problem" aria-label="Permalink to “Problem”">​</a></h2><p>Original specs allowed backends to either truncate or throw when prefixed storage keys exceeded limits, creating inconsistent cross-backend behavior. The same user key could produce different outcomes on different backends.</p><h2 id="decision" tabindex="-1">Decision <a class="header-anchor" href="#decision" aria-label="Permalink to “Decision”">​</a></h2><p>Make truncation <strong>mandatory</strong> when <code>prefix:userKey</code> exceeds backend storage limits:</p><ul><li>All backends MUST apply standardized hash-truncation via <code>makeStorageKey()</code></li><li>Throw <code>InvalidArgument</code> only when truncated form still exceeds absolute limits</li><li>Universal application to main lock keys, reverse index keys, and fence counter keys</li><li>Two-step fence key derivation ensures 1:1 mapping between user keys and fence counters</li></ul><h2 id="alternatives-brief" tabindex="-1">Alternatives (brief) <a class="header-anchor" href="#alternatives-brief" aria-label="Permalink to “Alternatives (brief)”">​</a></h2><ul><li>Allow throw or truncate — unpredictable cross-backend behavior</li><li>Always throw on long keys — poor DX, prevents valid use cases</li></ul><h2 id="impact" tabindex="-1">Impact <a class="header-anchor" href="#impact" aria-label="Permalink to “Impact”">​</a></h2><ul><li>Positive: Predictable behavior, testable cross-backend, composable applications</li><li>Negative/Risks: Requires common utility implementation across backends</li></ul><h2 id="links" tabindex="-1">Links <a class="header-anchor" href="#links" aria-label="Permalink to “Links”">​</a></h2><ul><li>Code/Docs: <code>docs/specs/interface.md</code> (Storage Key Generation, Fence Key Derivation), <code>common/crypto.ts</code></li><li>Related ADRs: ADR-013 (reverse index storage)</li></ul>',13)])])}const u=a(i,[["render",o]]);export{p as __pageData,u as default};
