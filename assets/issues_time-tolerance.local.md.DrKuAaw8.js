import{_ as t,c as i,o as s,aj as o}from"./chunks/framework.Bbpi2Fiw.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"issues/time-tolerance.local.md","filePath":"issues/time-tolerance.local.md","lastUpdated":0}'),a={name:"issues/time-tolerance.local.md"};function n(r,e,l,c,d,u){return s(),i("div",null,[...e[0]||(e[0]=[o("<p>Looking at the test results, the core functionality is working correctly. All 30 tests pass across Redis, PostgreSQL, and Firestore backends.</p><p>However, I noticed one thing worth mentioning:</p><p>The TIME_TOLERANCE_MS behavior - The library uses a 1000ms tolerance for determining if locks are &quot;live&quot;. This is by design (ADR-005) to handle clock skew between distributed systems, but it means:</p><ul><li>A lock with TTL 200ms won&#39;t report as expired until ~1200ms after acquisition</li><li>This is intentional for safety in distributed environments, but could surprise users expecting immediate expiration</li></ul><p>This isn&#39;t a bug - it&#39;s documented behavior. The tolerance prevents race conditions where a lock might appear expired on one node but still be considered valid on another due to clock drift.</p><p>Everything else looks solid:</p><ul><li>Acquire/release cycle works correctly</li><li>Mutual exclusion is enforced (second operation waits for first)</li><li>Fence tokens are monotonically increasing with correct 15-digit format</li><li>Lock extension works</li><li>AsyncDisposable (await using) releases locks properly</li><li>Error handling releases locks even when callbacks throw</li><li>Lookup operations return correct sanitized data</li></ul><p>The smoke tests confirm the NPM package is functioning as expected.</p><hr><p>The comment is essentially a heads-up, not a defect. The 1000ms tolerance is intentional (per ADR-005) to guard against clock skew, but it can surprise users with small TTLs. You don’t need to change code or tests unless you want to reduce surprise. If you want to act on it, the best moves are:</p><ul><li>Clarify docs: explicitly note that effective expiry = TTL + TIME_TOLERANCE_MS (default 1000ms), with an example (e.g., TTL 200ms → ~1200ms). Point to ADR-005 for rationale.</li><li>Surface configuration: if TIME_TOLERANCE_MS is tunable, mention how; if not, state it’s fixed and why.</li><li>Add a warning note near any public API that takes TTL so users set realistic values for tiny TTLs.</li><li>Optional: add a small test/example showing short TTL behavior to make expectations explicit.</li></ul><p>Otherwise, no immediate action is required; core functionality is confirmed working.</p>",12)])])}const h=t(a,[["render",n]]);export{m as __pageData,h as default};
